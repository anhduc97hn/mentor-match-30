import { NextResponse } from "next/server";
import { z, ZodObject } from "zod";
import { AppError, ExtendedNextRequest, RouteHandlerLogic, sendResponse } from "./helper";
import { HTTP_STATUS, ERROR_TYPES } from "../constants";
import UserProfile from "@/models/UserProfile"; 

type NextFunction = (err?: any) => void;
// Middleware now takes req and next, and returns a promise of a Response or void
type Middleware = (req: ExtendedNextRequest, next: NextFunction) => Promise<NextResponse | void>;
// type RouteHandlerLogic = (req: ExtendedNextRequest, context: RouteContext) => Promise<NextResponse>;

// Zod Validation Middleware ---
interface ValidationConfig {
  body?: ZodObject;
  query?: ZodObject;
}

export const validate = (config: ValidationConfig): Middleware => {
  return async (req, next) => {
    try {
      // 1. Validate Body (requires manual JSON parsing)
      if (config.body) {
        const body = await req.json().catch(() => ({}));

        const result = config.body.safeParse(body);

        if (!result.success) {
          const error = result.error.issues.map((e) => `${e.path.join(".")} validation failed: ${e.message}`).join(" & ");
          throw new AppError(HTTP_STATUS.UNPROCESSABLE_ENTITY, error, ERROR_TYPES.UNPROCESSABLE_ENTITY);
        }
        // Store the validated body for the handler to use
        req.validatedBody = result.data;
      }

      // 2. Validate `Query`
      if (config.query) {
        const query = Object.fromEntries(req.nextUrl.searchParams);

        const result = config.query.safeParse(query);

        if (!result.success) {
          const error = result.error.issues.map((e) => `${e.path.join(".")} validation failed: ${e.message}`).join(" & ");
          throw new AppError(HTTP_STATUS.BAD_REQUEST, error, ERROR_TYPES.BAD_REQUEST);
        }
        req.validatedQuery = result.data;
      }

      return next();
    } catch (error) {
      next(error);
    }
  };
};

// Role Access Middleware ---
export const checkUserRoleAccess = (requiredRole: "mentor" | "customer"): Middleware => {
  return async (req, next) => {
    try {
      // Get userId from the header injected by middleware.ts
      const userId = req.headers.get("x-user-id");
      if (!userId) {
        return next(new AppError(HTTP_STATUS.UNAUTHORIZED, "Login required", ERROR_TYPES.UNAUTHORIZED));
      }
      const userProfile = await UserProfile.findOne({ userId: userId }, "+isMentor");
      const hasAccess = (requiredRole === "mentor" && userProfile?.isMentor) || (requiredRole === "customer" && !userProfile?.isMentor);
      if (hasAccess) {
        return next();
      } else {
        return next(new AppError(HTTP_STATUS.UNAUTHORIZED, "Access denied", ERROR_TYPES.UNAUTHORIZED));
      }
    } catch (error) {
      next(error);
    }
  };
};

export const mentorAccessRequired = checkUserRoleAccess("mentor");
export const customerAccessRequired = checkUserRoleAccess("customer");

// Middleware Chainer (Essential HOF) ---
export const chainMiddleware = (middlewares: Middleware[], handler: RouteHandlerLogic): RouteHandlerLogic => {
  return async (req, context) => {
    let middlewareIndex = 0;
    let finalResponse: NextResponse | null = null;

    const next: NextFunction = async (err) => {
      if (err) {
        // If an error occurs, break the chain and propagate the error to catchAsync
        throw err;
      }

      const currentMiddleware = middlewares[middlewareIndex++];
      if (currentMiddleware) {
        // If the middleware returns a response (to stop the chain), store it
        const response = await currentMiddleware(req, next);
        if (response instanceof NextResponse) {
          finalResponse = response;
          return;
        }
      } else {
        // End of middleware chain: call the final route handler
        finalResponse = await handler(req, context);
      }
    };

    // Start the chain
    await next();

    if (finalResponse) {
      return finalResponse;
    }

    // Should be caught by catchAsync, but ensures type safety
    throw new AppError(HTTP_STATUS.SERVER_ERROR, "No response generated by handler chain.", ERROR_TYPES.SERVER_ERROR);
  };
};
